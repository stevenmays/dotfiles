---
description: Core coding guidelines and patterns
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# Coding Guidelines

## Function Design

Single responsibility, under 20 lines, early returns:

```typescript
// Bad: Deeply nested
function processOrder(order) {
    if (order) {
        if (order.items && order.items.length > 0) {
            if (order.status === 'new') {
                return true;
            }
        }
    }
    return false;
}

// Good: Early returns
function processOrder(order) {
    if (!order) return false;
    if (!order.items?.length) return false;
    if (order.status !== 'new') return false;
    return true;
}
```

## Error Handling

Top-level handling, real Error objects with context:

```typescript
async function processData(data) {
    try {
        return data.map(processItem);
    } catch (error) {
        // Non-critical: log and return default
        console.warn(`Processing warning: ${error.message}`);
        return getDefaultData();
    }
}

// Custom error when needed
export class ValidationError extends Error {
    constructor(message: string, public field?: string) {
        super(message);
        this.name = 'ValidationError';
    }
}
```

## Code Organization

```
src/
├── handlers/     # Entry points
├── lib/          # Business logic
└── scripts/      # Dev scripts
```

Keep related code together. Separate handlers from business logic.

## Prefer Functions Over Classes

```typescript
// Bad: Unnecessary class
class PriceCalculator {
    constructor(private taxRate: number) {}
    calculatePrice(basePrice: number) {
        return basePrice * (1 + this.taxRate);
    }
}

// Good: Simple function
function calculatePrice(basePrice: number, taxRate: number) {
    return basePrice * (1 + taxRate);
}
```

## Testing

Export pure functions. Separate I/O from business logic:

```typescript
// Testable pure function
export function calculateDiscount(order: Order): number {
    if (order.total > 100) return order.total * 0.1;
    return 0;
}

// Separate I/O from logic
async function processOrder(orderId: string) {
    const order = await fetchOrder(orderId);       // I/O
    const discount = calculateDiscount(order);     // Pure
    await updateOrder(orderId, { discount });      // I/O
}
```

## AI Anti-Patterns to Avoid

**Excessive comments:**
```typescript
// ❌ States the obvious
// Check if the user is valid
if (isValidUser(user)) {

// ✅ Explains why (keep these)
// Must check expiry before validation - expired tokens cause cryptic errors
if (isExpired(token)) return null;
```

**Gratuitous defensive checks:**
```typescript
// ❌ Remove if upstream already validates
function processOrder(order: Order) {
    if (!order) throw new Error('Order is required');  // Type guarantees this
}

// ✅ Keep at entry points
export async function handleRequest(event: APIGatewayEvent) {
    if (!event.body) return { statusCode: 400, body: 'Missing body' };
}
```

**Type escape hatches:**
```typescript
// ❌ Casting to any
const result = (data as any).value;

// ✅ Fix properly
const result = (<DataWithValue>data).value;
```

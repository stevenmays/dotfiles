---
description: TypeScript type patterns, interfaces, assertions, enums
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript Patterns

## Type Inference
Let TypeScript infer return types. Specify only when it adds clarity.

## Runtime Validation
Never hard cast `JSON.parse`. Use type guards:

```typescript
function isMyType(value: unknown): value is MyType {
    return typeof value === 'object' &&
        value !== null &&
        typeof (<MyType>value).prop === 'string';
}

const value = JSON.parse(message);
assert(isMyType(value), 'Invalid format');
```

## Type Guard Conventions
- Parameter: `value: unknown`
- Return boolean, never throw
- Use with `assert()` for concise validation

## Casting Syntax
Use angle brackets: `<Type>value` not `as Type`

## Interfaces
- No `I` prefix or `Data` suffix
- Properties in alphabetical order
- Think as adjectives: `Shippable`, `Refundable`
- When extending, inherit ALL properties (no `Omit`)

## Enums
- Always explicit values: `STATUS = 'status'`
- Use union types for 2-3 values
- Validate with `Object.values()` not `Object.keys()`

## Imports
Prefer namespace: `import * as lib from 'lib'`

## Organization
- Keep types with related code
- Only export public API types
